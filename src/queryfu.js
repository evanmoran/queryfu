// Generated by CoffeeScript 1.3.3
(function() {
  var QueryFu, queryfu, root, _hasOnlyKey, _isArrayEqual, _mergeFailed, _mergeOp, _mergeOpAtQuery;

  queryfu = function(path, operator, value) {
    var qf;
    qf = new QueryFu;
    return qf.where.apply(qf, arguments);
  };

  root = this;

  _isArrayEqual = function(arr1, arr2) {
    var k, v, _i, _len;
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (k = _i = 0, _len = arr1.length; _i < _len; k = ++_i) {
      v = arr1[k];
      if (arr2[k] !== v) {
        return false;
      }
    }
    return true;
  };

  _hasOnlyKey = function(obj, key) {
    return (_.isObject(obj)) && _isArrayEqual(_.keys(obj), [key]);
  };

  _mergeOpAtQuery = function(query) {};

  _mergeFailed = {};

  _mergeOp = function(operator, currentValue, value, key, errorList) {
    switch (operator) {
      case '<':
      case '<=':
        return Math.min(value, currentValue);
      case '>=':
      case '>':
        return Math.max(value, currentValue);
      case '=':
        if (currentValue !== value) {
          errorList.push("conflicting equality checks were found (key: " + key + ", values: " + currentValue + ", " + value + ")");
        }
        return value;
    }
    return _mergeFailed;
  };

  QueryFu = (function() {
    var _exprToMongo, _toMongoOp;

    function QueryFu(json, errors) {
      if (json == null) {
        json = {};
      }
      if (errors == null) {
        errors = [];
      }
      this._query = _.clone(json);
      this._errors = errors.slice(0);
    }

    QueryFu.prototype._inplaceWhere = function(path, operator, value) {
      var expr, expression, k, merged, subquery, v;
      if (arguments.length === 1 && _.isObject(path)) {
        for (k in path) {
          v = path[k];
          this._inplaceWhere(k, v);
        }
        return this;
      }
      if (arguments.length === 2) {
        if (_.isObject(operator)) {
          for (k in operator) {
            v = operator[k];
            this._inplaceWhere(path, k, v);
          }
          return this;
        }
        value = operator;
        operator = '=';
      }
      if (operator === '==') {
        operator = '=';
      }
      if ((expr = this._query[path]) != null) {
        if (!_.isObject(expr)) {
          expr = (this._query[path] = {
            '=': expr
          });
        }
        if (!(expr[operator] != null)) {
          expr[operator] = value;
        } else {
          merged = _mergeOp(operator, this._query[path][operator], value, path, this._errors);
          if (merged !== _mergeFailed) {
            this._query[path][operator] = merged;
            if (_hasOnlyKey(this._query[path], '=')) {
              this._query[path] = this._query[path]['='];
            }
          } else {
            subquery = {};
            subquery[path] = {};
            subquery[path][operator] = value;
            this._query = {
              '&': [this._query, subquery]
            };
          }
        }
      } else {
        switch (operator) {
          case '=':
          case '==':
            this._query[path] = value;
            break;
          case '!=':
          case '<':
          case '<=':
          case '>=':
          case '>':
            expression = {};
            expression[operator] = value;
            this._query[path] = expression;
        }
      }
      return this;
    };

    QueryFu.prototype.where = function() {
      var q;
      q = new QueryFu(this._query, this._errors);
      return q._inplaceWhere.apply(q, arguments);
    };

    QueryFu.prototype.and = function() {
      return this.where.apply(this, arguments);
    };

    QueryFu.prototype.error = function() {
      return this._errors.join('\n');
    };

    QueryFu.prototype.toJSON = function() {
      return this._query;
    };

    _toMongoOp = function(op, value) {
      var answer, opMap;
      answer = {};
      opMap = {
        '<': '$lt',
        '>': '$gt',
        '<=': '$lte',
        '>=': '$gte'
      };
      if (opMap[op] != null) {
        answer[opMap[op]] = value;
      } else if (op === '!=') {
        answer['$not'] = value;
      }
      return answer;
    };

    _exprToMongo = function(expr) {
      var mongoExpr, op, val;
      if (_.isObject(expr)) {
        mongoExpr = {};
        for (op in expr) {
          val = expr[op];
          _.extend(mongoExpr, _toMongoOp(op, val));
        }
        return mongoExpr;
      } else {
        return expr;
      }
    };

    QueryFu.prototype.toMongo = function(query) {
      var equalities, expr, mongo, path;
      if (query == null) {
        query = this._query;
      }
      if (_hasOnlyKey(query, '&')) {
        return {
          '$and': _.map(query['&'], this.toMongo)
        };
      }
      mongo = {};
      equalities = {};
      for (path in query) {
        expr = query[path];
        mongo[path] = _exprToMongo(expr);
        if (expr['='] != null) {
          equalities[path] = expr['='];
        }
      }
      if ((_.keys(equalities)).length) {
        mongo = {
          '$and': [mongo, this.toMongo(equalities)]
        };
      }
      return mongo;
    };

    return QueryFu;

  })();

  queryfu.where = queryfu;

  queryfu.version = '0.0.1';

  module.exports = queryfu;

}).call(this);
